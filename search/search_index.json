{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HomeReloaded: Messaging Module","text":"Assert.Equal(funnyMessage, Dio)"},{"location":"#introduction","title":"Introduction","text":"<p>Reloaded.Networking is library that adds support for simple, high performance message packing to existing networking libraries.  </p> <p>Specifically, it provides a minimal framework for performing the following tasks:  </p> <ul> <li>Asynchronous message processing for external networking libraries.  </li> <li>Setting up host &amp; client (for supported libraries).  </li> <li>Sending/Receiving messages with (de)serialization and [optional] (de)compression.  </li> <li>Automatically dispatching messages to appropriate handlers (per message type).  </li> </ul> <p>It was originally created for Reloaded II, however has been extended in the hope of becoming a more general purpose library.  </p> <p>This library is heavily optimized for achieving high throughput for messages <code>&lt; 128KB</code>.  </p>"},{"location":"#characteristics","title":"Characteristics","text":"<ul> <li>High performance. (Memory pooling, low heap allocation).  </li> <li>Low networking overhead.  </li> <li>Custom serializer/compressor per class type.  </li> <li>Simple message packing/protocol.  </li> <li>1 byte overhead for uncompressed, 5 bytes for compressed.  </li> <li>Unsafe.  </li> </ul>"},{"location":"benchmarks/","title":"Sample Benchmarks","text":"<p>Performed using Version 2.0.0 on the following configuration:  </p> <pre><code>BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19044.1806 (21H2)\nIntel Core i7-4790K CPU 4.00GHz (Haswell), 1 CPU, 8 logical and 4 physical cores\n.NET SDK=7.0.100-preview.5.22307.18\n  [Host] : .NET 6.0.6 (6.0.622.26707), X64 RyuJIT\n</code></pre> <p>All benchmarks performed on single thread; albeit library is safe to use with multiple threads.</p>"},{"location":"benchmarks/#message-unpacker-dispatcher-benchmarks","title":"Message Unpacker &amp; Dispatcher Benchmarks","text":"<p>This is a benchmark of <code>MessageDispatcher&lt;T&gt;</code>.  </p> <p>This benchmark measures the time taken to: - Decode Message Header (Unpack) - Send Message to Handler for Deserialization  </p> <pre><code>|        Method | NumItems |     Mean |     Error |    StdDev | Ratio | Operations/s | Allocated |\n|-------------- |--------- |---------:|----------:|----------:|------:|-------------:|----------:|\n| HandleMessage |   100000 | 1.038 ms | 0.0167 ms | 0.0148 ms |  1.00 |  96332329.33 |       2 B |\n</code></pre> <p>Around 96 million messages per second.  </p>"},{"location":"benchmarks/#message-creation-benchmarks","title":"Message Creation Benchmarks","text":"<p>This is a benchmark of <code>MessageWriter.Serialize</code>.  </p> <p>This benchmark measures the time taken to: - Create &amp; Dispose container used for storing packed message. (<code>Microsoft.IO.RecyclableMemoryStream</code>) - Create Message Header. - Pack Message (combine header + raw data).  </p> <pre><code>|                             Method | NumItems |         Mean |      Error |     StdDev |    Ratio | RatioSD |  Operations/s | Allocated |\n|----------------------------------- |--------- |-------------:|-----------:|-----------:|---------:|--------:|--------------:|----------:|\n|        DummySerializeOnly_BASELINE |   100000 |     13.85 us |   0.062 us |   0.058 us |     1.00 |    0.00 | 7222495640.56 |         - |\n|            DummySerialize_And_Pack |   100000 |  7,294.25 us |  53.658 us |  47.567 us |   526.71 |    4.73 |   13709434.85 |       8 B |\n| DummySerialize_And_Pack_Compressed |   100000 | 20,060.07 us | 228.341 us | 213.590 us | 1,448.88 |   17.92 |    4985028.25 |      50 B |\n</code></pre> <p>Key: - DummySerializeOnly_BASELINE: <code>Overhead of non-packing related code.</code> - DummySerialize_And_Pack: <code>Time taken to pack all messages without compression.</code> - DummySerialize_And_Pack_Compressed: <code>Time taken to pack all messages with compression header.</code> </p>"},{"location":"benchmarks/#real-world-scenario-benchmarks","title":"Real World Scenario Benchmarks","text":"<p>The following benchmark measures the time taken to serialize: - A real world configuration file into JSON. - And run it through the library.  </p> Method NumItems Mean Error StdDev Ratio RatioSD Operations/s Gen 0 Allocated SerializeOnly_NoPack_To_SingleBuffer 100000 155.6 ms 2.76 ms 2.59 ms 1.00 0.00 642735.51 - 1,614,672 B SerializeOnly_NoPack_To_BufferPerMessage 100000 205.6 ms 2.36 ms 2.21 ms 1.32 0.02 486273.70 6000.0000 26,400,624 B Serialize_And_Pack 100000 157.6 ms 1.43 ms 1.34 ms 1.01 0.02 634681.18 - 252 B Serialize_And_Pack_And_Handle 100000 156.9 ms 1.97 ms 1.84 ms 1.01 0.02 637216.58 - 420 B Serialize_And_Pack_And_Handle_And_Unpack_And_Deserialize 100000 581.8 ms 7.88 ms 7.37 ms 3.74 0.06 171887.71 50000.0000 209,719,272 B <ul> <li>SerializeOnly_NoPack_To_SingleBuffer: <code>Time taken to serialize all messages into a single memory buffer</code>.  </li> <li>SerializeOnly_NoPack_To_BufferPerMessage: <code>Time taken to serialize all messages into 1 memory buffer per message</code>.  </li> <li>Serialize_And_Pack: <code>Time taken to serialize and pack every message using the library.</code> </li> <li>Serialize_And_Pack_And_Handle: <code>Time taken to serialize, pack and send message via MessageDispatcher&lt;T&gt;.</code> </li> <li>Serialize_And_Pack_And_Handle_And_Unpack_And_Deserialize: <code>Provided for completeness to measure theoretical throughput.</code> </li> </ul> <p>From these results we can extrapolate that: - Overhead for packing a message is 1-2ms per 100,000 items; (<code>SerializeOnly_NoPack_To_SingleBuffer</code> - <code>Serialize_And_Pack</code>).  </p>"},{"location":"benchmarks/#additional-benchmarks","title":"Additional Benchmarks","text":"<p>Further benchmarks can be found in the <code>Reloaded.Messaging.Benchmarks</code> project.  </p>"},{"location":"defining-structures/","title":"Creating Structures &amp; Messages","text":""},{"location":"defining-structures/#creating-message-structures","title":"Creating Message Structures","text":"<p>Note</p> <p>The library heavily (ab)uses generics for optimal code generation and maximum throughput.  </p> <p>First, a struct or class must be annotated by implementing the <code>IMessage</code> interface.  </p> <pre><code>// Structures can specify their own custom serializer(s) and compressor(s).  \n// IMessage&lt;TStruct, TSerializer, TCompressor&gt;\npublic struct Vector3 : IMessage&lt;Vector3, SystemTextJsonSerializer&lt;Vector3&gt;, DummyCompressor&gt;\n{\n    // IMessage\n    public sbyte GetMessageType() =&gt; (sbyte)MessageType.Vector3;\n    public SystemTextJsonSerializer&lt;Vector3SystemTextJson&gt; GetSerializer() =&gt; new();\n    public DummyCompressor? GetCompressor() =&gt; null;\n\n    // Example Data\n    public float X { get; set; }\n    public float Y { get; set; }\n    public float Z { get; set; }\n}\n</code></pre> <p>Each message must define the following methods: - <code>GetMessageType</code>: Returns the unique message type. Valid values are between 0 and 127. - <code>GetSerializer</code>: Returns an instance of the serializer used to serialize/deserialize the message. - <code>GetCompressor</code>: Returns an instance of the compressor used to compress/decompress the message.  </p> <p>The type of serializer (<code>TSerializer</code>) and type of compressor (<code>TCompressor</code>) are defined in the <code>IMessage</code> interface; here they are <code>SystemTextJsonSerializer</code> and <code>DummyCompressor</code> specifically.  </p> <p>Return <code>null</code> for compressor if no compression is requested.  </p>"},{"location":"defining-structures/#pack-messages","title":"Pack Messages","text":"<p>To pack an instance (including serialization &amp; compression), call the extension method <code>Serialize()</code> in <code>Reloaded.Messaging.Messages.MessageWriterExtensions</code>.  </p> <pre><code>var sample = new Vector3(0.0f, 1.0f, 2.0f);\nusing var serialized = sample.Serialize(ref sample);\n\n// Access message via `serialized.Span`.\n// You can now e.g. send this message over the network.\nClient.FirstPeer.Send(serialized.Span, DeliveryMethod.ReliableOrdered);\n</code></pre> <p>Danger</p> <p>Serialization result must be disposed before serializing another instance due to internal pooling. The return value <code>ReusableSingletonMemoryStream</code> can have at most 1 instance per thread.  </p> <p>Alternative lower level API: <code>MessageWriter&lt;TStruct, TSerializer, TCompressor&gt;</code>.  </p>"},{"location":"defining-structures/#unpack-messages","title":"Unpack Messages","text":"<p>Info</p> <p>Provided for completeness, this is usually automated for you. Only low level API provided.  </p> <pre><code>// Read message header.\nHeaderReader.ReadHeader(message.Span, out var messageType, out var compressedSize, out var headerSize);\n\n// Create deserializer &amp; deserialize\n// Generic arguments to MessageReader are same as ones to IMessage.\nvar deserialize  = new MessageReader&lt;Vector3ReloadedMemoryDummyCompression, UnmanagedReloadedMemorySerializer&lt;Vector3ReloadedMemoryDummyCompression&gt;, NullCompressor&gt;(in structure);\nVector3 deserialized = deserialize.Deserialize(message.Span.Slice(headerSize), compressedSize);\n</code></pre>"},{"location":"message-structure/","title":"Message Structure","text":"<p>Each message uses the following structure:  </p> <pre><code>- [7 bits] Message Type\n- [1 bit ] Compression Flag\n- [0/4 bytes] Decompressed Size\n- [Remaining bytes] Message\n</code></pre> <p>Messages are deliberately simple, to avoid unnecessary complexity.  </p>"},{"location":"message-structure/#message-type","title":"Message Type","text":"<p>This is denoted by <code>TMessageType</code> within the library, and is user defined. Each message type can be assigned 1 handler.  </p> <p>Type: Signed byte Values: <code>0x0 - 0x7F</code> Mask: <code>0b0111_1111</code> </p>"},{"location":"message-structure/#compression-flag","title":"Compression Flag","text":"<p>Set in leftmost bit of message type. 1 if the message contains compression, else 0.  </p> <p>Type: Single bit Values: <code>0x0 - 0x1</code> Mask: <code>0b1000_0000</code> </p>"},{"location":"message-structure/#decompressed-size","title":"Decompressed Size","text":"<p>Expected size after decompression. Used for compressors to allow for memory pre-allocation.  </p> <p>Type: Signed 32-bit integer. Optional: Used only if struct defines a compressor.  </p> <p>Values: - <code>0x0 - 0x7FFFFFFF</code>: Expected size of decompressed message.  </p> <p>Uses <code>Little Endian</code>.  </p> <p>The resulting data is always compressed, regardless of whether it ended up being larger or smaller than the original in order to improve throughput (avoids a memory copy).  </p> <p>Reason for signed vs unsigned lies in limitations of some languages (incl. .NET), memory pools often don't support 4GB arrays.  </p>"},{"location":"message-structure/#message","title":"Message","text":"<p>Raw message in bytes. How message is stored depends on serializer.  </p>"},{"location":"running-host/","title":"Running a Host","text":"<p>The following article shows how to run an example host. For a more complete example, look at Unit Tests.  </p>"},{"location":"running-host/#create-a-host","title":"Create a Host","text":"<p>Note</p> <p>The hosts in <code>Reloaded.Messaging</code> do the minimal amount of setup to enable asynchronous message handling. They do not abstract the base libraries; for guidance on using them, please refer to their individual documentation(s).  </p> <pre><code>Server = new LiteNetLibHost&lt;MessageDispatcher&lt;LiteNetLibState&gt;&gt;(true, new MessageDispatcher&lt;LiteNetLibState&gt;());\nClient = new LiteNetLibHost&lt;MessageDispatcher&lt;LiteNetLibState&gt;&gt;(true, new MessageDispatcher&lt;LiteNetLibState&gt;());\n\n// Start listening and connect.\n// This is LiteNetLib specific code.\nServer.Manager.Start(IPAddress.Loopback, IPAddress.IPv6Loopback, 0);\nClient.Manager.Start(IPAddress.Loopback, IPAddress.IPv6Loopback, 0);\nClient.Manager.Connect(new IPEndPoint(IPAddress.Loopback, Server.Manager.LocalPort), DefaultPassword);\n</code></pre> <p>All pre-implemented hosts derive from the <code>IHost&lt;TExtraData&gt;</code> class. <code>TExtraData</code> is a generic type used to encapsulate the current state of the host. In the case of <code>LiteNetLib</code>, it is called <code>LiteNetLibState</code>.  </p>"},{"location":"running-host/#sending-messages","title":"Sending Messages","text":"<p>Each host implements the functions <code>SendFirstPeer</code> and <code>SendToAll</code>.  </p> <p>Recall the serialization example from earlier:  </p> <pre><code>var sample = new Vector3(0.0f, 1.0f, 2.0f);\nusing var serialized = sample.Serialize(ref sample);\n\n// Client is an IHost.\nClient.SendFirstPeer(serialized.Span);\n</code></pre>"},{"location":"running-host/#receiving-messages","title":"Receiving Messages","text":"<p>In order to receive messages, you must first register a handler for the message type. You can do that by calling <code>AddToDispatcher</code> on the message type and providing: - Class/struct that implements <code>IMsgRefAction&lt;TMessage, TExtraData&gt;</code>. - The <code>Dispatcher</code> from the <code>IHost</code> instance.  </p> <pre><code>var messageHandler = new LiteNetLibMessageHandler();\nmessageHandler.Received.AddToDispatcher(messageHandler, ref Client.Dispatcher);\n\n// Class that will process received `Vector3`s from Host.\npublic class LiteNetLibMessageHandler : IMsgRefAction&lt;Vector3, LiteNetLibState&gt;\n{\n    public void OnMessageReceive(ref Vector3 received, ref LiteNetLibState data)\n    {\n        // Executed on every Vector3 received from host.\n        // e.g. You can process message and send response with \n        //      data.Peer.Send();\n    }\n}\n</code></pre> <p>Any instance of a class/struct that implements <code>IMsgRefAction</code> is fine. You can of course implement multiple <code>IMsgRefAction</code> in the same class/struct too.  </p> <p>The hosts are automatically configured to asynchronously receive messages, there is no need to manually call <code>Receive</code> or any similar function(s).  </p>"},{"location":"serializers-compressors/","title":"Serializers &amp; Compressors","text":""},{"location":"serializers-compressors/#existing-serializers","title":"Existing Serializers","text":"<p>All NuGet packages are prefixed with <code>Reloaded.Messaging</code> unless otherwise specified.  </p> Serializer NuGet Package Format Example Use Case SystemTextJsonSerializerSourceGeneratedSystemTextJsonSerializer Extras.Runtime JSON Human Readable Data MessagePackSerializer Serializer.MessagePack MsgPack High Performance, Small Message Size UnmanagedReloadedMemorySerializer Serializer.ReloadedMemory Binary Raw struct/byte conversion.  When versioning is not needed and client/host use same endian."},{"location":"serializers-compressors/#existing-compressors","title":"Existing Compressors","text":"Compressor NuGet Package Example Use Case BrotliCompressor Extras.Runtime Compressing structured data (e.g. JSON) ZStandardCompressor Compressor.ZStandard Binary compression. Very good with pre-trained dictionary."},{"location":"serializers-compressors/#implementing-your-own","title":"Implementing your Own","text":"<p>Implementing serializers and compressors is simple, create structs that implement the <code>ISerializer</code> and <code>ICompressor</code> interfaces. Below are some example(s).  </p>"},{"location":"serializers-compressors/#example-serializer","title":"Example Serializer","text":"<pre><code>/// &lt;inheritdoc /&gt;\npublic struct SystemTextJsonSerializer&lt;TStruct&gt; : ISerializer&lt;TStruct&gt;\n{\n    /// &lt;summary&gt;\n    /// Serialization options.\n    /// &lt;/summary&gt;\n    public JsonSerializerOptions Options { get; private set; }\n\n    /// &lt;summary&gt;\n    /// Creates the System.Text.Json based serializer.\n    /// &lt;/summary&gt;\n    public SystemTextJsonSerializer() { Options = new JsonSerializerOptions(); }\n\n    /// &lt;summary&gt;\n    /// Creates the System.Text.Json based serializer.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"serializerOptions\"&gt;Options to use for serialization/deserialization.&lt;/param&gt;\n    public SystemTextJsonSerializer(JsonSerializerOptions serializerOptions) { Options = serializerOptions; }\n\n    /// &lt;inheritdoc /&gt;\n    public TStruct Deserialize(Span&lt;byte&gt; serialized)\n    {\n        return JsonSerializer.Deserialize&lt;TStruct&gt;(serialized, Options)!;\n    }\n\n    /// &lt;inheritdoc /&gt;\n    public void Serialize(ref TStruct item, IBufferWriter&lt;byte&gt; writer)\n    {\n        var write = Pool.JsonWriterPerThread();\n        write.Reset(writer);\n        JsonSerializer.Serialize(write, item, Options);\n    }\n}\n</code></pre>"},{"location":"serializers-compressors/#example-compressor","title":"Example Compressor","text":"<pre><code>/// &lt;summary&gt;\n/// Provides brotli compression support.\n/// &lt;/summary&gt;\npublic struct BrotliCompressor : ICompressor\n{\n    private byte _quality;\n    private byte _window;\n\n    /// &lt;summary&gt;\n    /// Creates the default brotli compressor.\n    /// &lt;/summary&gt;\n    public BrotliCompressor()\n    {\n        _window = 22;\n        _quality = 9;\n    }\n\n    /// &lt;summary/&gt;\n    /// &lt;param name=\"quality\"&gt;Quality of encoder. Between 0 and 11. Recommend 9 for size/speed ratio.&lt;/param&gt;\n    /// &lt;param name=\"window\"&gt;Size of window.&lt;/param&gt;\n    public BrotliCompressor(byte quality, byte window = 22)\n    {\n        _quality = quality;\n        _window = window;\n    }\n\n    /// &lt;inheritdoc /&gt;\n    public int GetMaxCompressedSize(int inputSize) =&gt; BrotliEncoder.GetMaxCompressedLength(inputSize);\n\n    /// &lt;inheritdoc /&gt;\n    public int Compress(Span&lt;byte&gt; uncompressedData, Span&lt;byte&gt; compressedData)\n    {\n        using var encoder = new BrotliEncoder(_quality, _window);\n        encoder.Compress(uncompressedData, compressedData, out _, out var bytesWritten, true);\n        return bytesWritten;\n    }\n\n    /// &lt;inheritdoc /&gt;\n    public void Decompress(Span&lt;byte&gt; compressedBuf, Span&lt;byte&gt; uncompressedBuf)\n    {\n        using var decoder = new BrotliDecoder();\n        decoder.Decompress(compressedBuf, uncompressedBuf, out _, out _);\n    }\n}\n</code></pre>"}]}